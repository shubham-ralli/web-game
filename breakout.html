<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Breakout — HTML5 Canvas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#0f172a;color:#e2e8f0;font-family:system-ui,Arial}
    .wrap{display:grid;place-items:center;height:100%}
    canvas{background:#0b1022;border:2px solid #1f2937;border-radius:12px;touch-action:none}
    .hud{position:fixed;top:14px;left:50%;transform:translateX(-50%);display:flex;gap:16px;font-weight:600}
    .btn{position:fixed;right:14px;top:10px;background:#334155;color:#e2e8f0;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    .btn:hover{filter:brightness(1.1)}
  </style>
</head>
<body>
  <div class="hud">
    <div id="score">Score: 0</div>
    <div id="lives">Lives: 3</div>
    <div id="hi">Best: 0</div>
  </div>
  <button class="btn" id="reset">Reset</button>
  <div class="wrap">
    <canvas id="game" width="480" height="640"></canvas>
  </div>

  <script>
    // --- Canvas & context
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // --- HUD
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const hiEl = document.getElementById('hi');
    const resetBtn = document.getElementById('reset');

    // --- Game constants
    const W = canvas.width, H = canvas.height;
    const PADDLE_W = 90, PADDLE_H = 14, PADDLE_Y = H - 36, PADDLE_SPEED = 460;
    const BALL_R = 7;
    const ROWS = 6, COLS = 8, BRICK_W = 52, BRICK_H = 20, BRICK_GAP = 8, TOP_OFFSET = 70, LEFT_OFFSET = 24;
    const COLORS = ['#60a5fa','#34d399','#f472b6','#fbbf24','#22d3ee','#a78bfa'];

    // --- Game state
    let paddleX = (W - PADDLE_W) / 2;
    let input = { left:false, right:false };
    let ball = { x: W/2, y: PADDLE_Y - BALL_R - 2, vx: 180, vy: -260 };
    let bricks = [];
    let score = 0;
    let lives = 3;
    let best = Number(localStorage.getItem('breakout_best') || 0);
    hiEl.textContent = 'Best: ' + best;

    // --- Build bricks grid
    function resetBricks() {
      bricks = [];
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          bricks.push({
            x: LEFT_OFFSET + c * (BRICK_W + BRICK_GAP),
            y: TOP_OFFSET  + r * (BRICK_H + BRICK_GAP),
            w: BRICK_W, h: BRICK_H, alive: true, color: COLORS[r % COLORS.length]
          });
        }
      }
    }
    resetBricks();

    // --- Input (keyboard)
    window.addEventListener('keydown', e=>{
      if (e.key === 'ArrowLeft' || e.key === 'a') input.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd') input.right = true;
    });
    window.addEventListener('keyup', e=>{
      if (e.key === 'ArrowLeft' || e.key === 'a') input.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd') input.right = false;
    });

    // --- Touch / mouse drag
    let dragging = false;
    function setPaddleFromClientX(cx){
      const rect = canvas.getBoundingClientRect();
      const x = cx - rect.left;
      paddleX = Math.max(0, Math.min(W - PADDLE_W, x - PADDLE_W/2));
    }
    canvas.addEventListener('pointerdown', e=>{ dragging = true; setPaddleFromClientX(e.clientX); });
    window.addEventListener('pointermove', e=>{ if (dragging) setPaddleFromClientX(e.clientX); });
    window.addEventListener('pointerup', ()=> dragging = false);

    // --- Helpers
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function rectCircleCollide(rx, ry, rw, rh, cx, cy, cr){
      const nx = clamp(cx, rx, rx + rw);
      const ny = clamp(cy, ry, ry + rh);
      const dx = cx - nx, dy = cy - ny;
      return (dx*dx + dy*dy) <= cr*cr;
    }

    function resetBall(){
      ball.x = paddleX + PADDLE_W/2;
      ball.y = PADDLE_Y - BALL_R - 2;
      // Randomize initial angle slightly
      const speed = 320;
      const angle = (-Math.PI/3) + (Math.random()*Math.PI/6); // between -60° and -30°
      ball.vx = Math.cos(angle)*speed;
      ball.vy = Math.sin(angle)*speed;
    }
    resetBall();

    // --- Update
    let last = 0;
    function update(dt){
      // Move paddle (keyboard)
      if (!dragging) {
        if (input.left)  paddleX -= PADDLE_SPEED * dt;
        if (input.right) paddleX += PADDLE_SPEED * dt;
        paddleX = clamp(paddleX, 0, W - PADDLE_W);
      }

      // Move ball
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // Walls
      if (ball.x < BALL_R){ ball.x = BALL_R; ball.vx *= -1; }
      if (ball.x > W - BALL_R){ ball.x = W - BALL_R; ball.vx *= -1; }
      if (ball.y < BALL_R){ ball.y = BALL_R; ball.vy *= -1; }

      // Bottom / lose life
      if (ball.y > H + BALL_R){
        lives--;
        livesEl.textContent = 'Lives: ' + lives;
        if (lives <= 0) {
          // reset game
          if (score > best){ best = score; localStorage.setItem('breakout_best', best); }
          score = 0; lives = 3; resetBricks();
          hiEl.textContent = 'Best: ' + best;
          scoreEl.textContent = 'Score: ' + score;
          livesEl.textContent = 'Lives: ' + lives;
        }
        resetBall();
      }

      // Paddle collision
      if (rectCircleCollide(paddleX, PADDLE_Y, PADDLE_W, PADDLE_H, ball.x, ball.y, BALL_R)){
        ball.y = PADDLE_Y - BALL_R - 0.1;
        ball.vy *= -1;

        // Add "english" based on hit position
        const hit = (ball.x - (paddleX + PADDLE_W/2)) / (PADDLE_W/2);
        ball.vx += hit * 80; // slight horizontal tweak
      }

      // Brick collisions
      for (const b of bricks){
        if (!b.alive) continue;
        if (rectCircleCollide(b.x, b.y, b.w, b.h, ball.x, ball.y, BALL_R)){
          b.alive = false;
          score += 10;
          scoreEl.textContent = 'Score: ' + score;

          // Reflect ball—decide axis based on where it hit
          const prevX = ball.x - ball.vx * dt;
          const prevY = ball.y - ball.vy * dt;
          const hitHoriz = prevX < b.x || prevX > b.x + b.w;
          if (hitHoriz) ball.vx *= -1; else ball.vy *= -1;
          break;
        }
      }

      // Win condition (all bricks cleared)
      if (bricks.every(b => !b.alive)){
        resetBricks();
        // slight speed-up
        ball.vx *= 1.05;
        ball.vy *= 1.05;
      }
    }

    // --- Render
    function draw(){
      // Clear
      ctx.clearRect(0,0,W,H);

      // Background grid
      ctx.globalAlpha = 0.07;
      for (let y=0; y<H; y+=20){
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.strokeStyle='#93c5fd'; ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Bricks
      for (const b of bricks){
        if (!b.alive) continue;
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, b.y, b.w, b.h);
        ctx.strokeStyle = '#0b132b';
        ctx.strokeRect(b.x+0.5, b.y+0.5, b.w-1, b.h-1);
      }

      // Paddle
      ctx.fillStyle = '#e5e7eb';
      ctx.fillRect(paddleX, PADDLE_Y, PADDLE_W, PADDLE_H);

      // Ball
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI*2);
      ctx.fillStyle = '#f97316';
      ctx.fill();

      // Title / tips
      ctx.fillStyle = '#a3e635';
      ctx.font = 'bold 16px system-ui, Arial';
      ctx.fillText('Breakout', 14, 24);
      ctx.fillStyle = '#94a3b8';
      ctx.font = '12px system-ui, Arial';
      ctx.fillText('←/→ arrows or drag to move', 14, 44);
    }

    // --- Loop
    function loop(ts){
      const dt = Math.min(0.032, (ts - last) / 1000 || 0.016); // cap delta
      last = ts;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // --- Reset button
    resetBtn.addEventListener('click', ()=>{
      score = 0; lives = 3; resetBricks(); resetBall();
      scoreEl.textContent = 'Score: ' + score;
      livesEl.textContent = 'Lives: ' + lives;
    });
  </script>
</body>
</html>
